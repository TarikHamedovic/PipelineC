/* Generated by Yosys 0.40+22 (git sha1 fa0c5c1d4, clang++ 14.0.0-1ubuntu1.1 -fPIC -Os) */

module bin_op_eq_uint25_t_uint25_t_0clk_de264c78(left, right, return_output);
  wire _0_;
  wire [101:0] \56.read_pipe ;
  input [24:0] left;
  wire [24:0] left;
  output return_output;
  wire return_output;
  input [24:0] right;
  wire [24:0] right;
  assign _0_ = left == right;
  assign return_output = _0_ ? 1'h1 : 1'h0;
  assign \56.read_pipe  = { left, right, 52'hzzzzzzzzzzzzz };
endmodule

module bin_op_plus_uint25_t_uint1_t_0clk_de264c78(left, right, return_output);
  wire [204:0] \158.read_pipe ;
  input [24:0] left;
  wire [24:0] left;
  output [25:0] return_output;
  wire [25:0] return_output;
  input right;
  wire right;
  assign return_output = { 1'h0, left } + { 25'h0000000, right };
  assign \158.read_pipe  = { left, right, 179'hzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz };
endmodule

module blink_0clk_a5a1cd4e(clk, clock_enable, return_output);
  wire _0_;
  wire [24:0] _1_;
  reg [24:0] bin_op_eq_blink_c_l17_c6_5cdf_left = 25'h0000000;
  wire bin_op_eq_blink_c_l17_c6_5cdf_return_output;
  wire [24:0] bin_op_eq_blink_c_l17_c6_5cdf_right;
  wire [24:0] bin_op_plus_blink_c_l26_c5_29f1_left;
  (* unused_bits = "25" *)
  wire [25:0] bin_op_plus_blink_c_l26_c5_29f1_return_output;
  wire bin_op_plus_blink_c_l26_c5_29f1_right;
  input clk;
  wire clk;
  wire clk_en_internal;
  input clock_enable;
  wire clock_enable;
  wire [24:0] counter;
  wire counter_mux_blink_c_l17_c3_f797_cond;
  wire [24:0] counter_mux_blink_c_l17_c3_f797_iffalse;
  wire [24:0] counter_mux_blink_c_l17_c3_f797_iftrue;
  wire [24:0] counter_mux_blink_c_l17_c3_f797_return_output;
  wire led;
  wire led_mux_blink_c_l17_c3_f797_cond;
  reg led_mux_blink_c_l17_c3_f797_iffalse = 1'h0;
  wire led_mux_blink_c_l17_c3_f797_iftrue;
  wire led_mux_blink_c_l17_c3_f797_return_output;
  wire [24:0] reg_comb_counter;
  wire reg_comb_led;
  output return_output;
  wire return_output;
  wire unary_op_not_blink_c_l20_c12_3a28_expr;
  wire unary_op_not_blink_c_l20_c12_3a28_return_output;
  always @(posedge clk)
    if (clock_enable) led_mux_blink_c_l17_c3_f797_iffalse <= _0_;
  always @(posedge clk)
    if (clock_enable) bin_op_eq_blink_c_l17_c6_5cdf_left <= _1_;
  assign _0_ = clock_enable ? reg_comb_led : 1'hx;
  assign _1_ = clock_enable ? reg_comb_counter : 25'hxxxxxxx;
  bin_op_eq_uint25_t_uint25_t_0clk_de264c78 bin_op_eq_blink_c_l17_c6_5cdf (
    .left(bin_op_eq_blink_c_l17_c6_5cdf_left),
    .return_output(counter_mux_blink_c_l17_c3_f797_cond),
    .right(25'h1fca054)
  );
  bin_op_plus_uint25_t_uint1_t_0clk_de264c78 bin_op_plus_blink_c_l26_c5_29f1 (
    .left(bin_op_eq_blink_c_l17_c6_5cdf_left),
    .return_output(bin_op_plus_blink_c_l26_c5_29f1_return_output),
    .right(1'h1)
  );
  mux_uint1_t_uint25_t_uint25_t_0clk_de264c78 counter_mux_blink_c_l17_c3_f797 (
    .cond(counter_mux_blink_c_l17_c3_f797_cond),
    .iffalse(bin_op_plus_blink_c_l26_c5_29f1_return_output[24:0]),
    .iftrue(25'h0000000),
    .return_output(reg_comb_counter)
  );
  mux_uint1_t_uint1_t_uint1_t_0clk_de264c78 led_mux_blink_c_l17_c3_f797 (
    .cond(counter_mux_blink_c_l17_c3_f797_cond),
    .iffalse(led_mux_blink_c_l17_c3_f797_iffalse),
    .iftrue(led_mux_blink_c_l17_c3_f797_iftrue),
    .return_output(reg_comb_led)
  );
  unary_op_not_uint1_t_0clk_de264c78 unary_op_not_blink_c_l20_c12_3a28 (
    .expr(led_mux_blink_c_l17_c3_f797_iffalse),
    .return_output(led_mux_blink_c_l17_c3_f797_iftrue)
  );
  assign bin_op_eq_blink_c_l17_c6_5cdf_return_output = counter_mux_blink_c_l17_c3_f797_cond;
  assign bin_op_eq_blink_c_l17_c6_5cdf_right = 25'h1fca054;
  assign bin_op_plus_blink_c_l26_c5_29f1_left = bin_op_eq_blink_c_l17_c6_5cdf_left;
  assign bin_op_plus_blink_c_l26_c5_29f1_right = 1'h1;
  assign clk_en_internal = clock_enable;
  assign counter = bin_op_eq_blink_c_l17_c6_5cdf_left;
  assign counter_mux_blink_c_l17_c3_f797_iffalse = bin_op_plus_blink_c_l26_c5_29f1_return_output[24:0];
  assign counter_mux_blink_c_l17_c3_f797_iftrue = 25'h0000000;
  assign counter_mux_blink_c_l17_c3_f797_return_output = reg_comb_counter;
  assign led = led_mux_blink_c_l17_c3_f797_iffalse;
  assign led_mux_blink_c_l17_c3_f797_cond = counter_mux_blink_c_l17_c3_f797_cond;
  assign led_mux_blink_c_l17_c3_f797_return_output = reg_comb_led;
  assign return_output = reg_comb_led;
  assign unary_op_not_blink_c_l20_c12_3a28_expr = led_mux_blink_c_l17_c3_f797_iffalse;
  assign unary_op_not_blink_c_l20_c12_3a28_return_output = led_mux_blink_c_l17_c3_f797_iftrue;
endmodule

module mux_uint1_t_uint1_t_uint1_t_0clk_de264c78(cond, iftrue, iffalse, return_output);
  wire [3:0] \115.read_pipe ;
  input cond;
  wire cond;
  input iffalse;
  wire iffalse;
  input iftrue;
  wire iftrue;
  output return_output;
  wire return_output;
  assign return_output = cond ? iftrue : iffalse;
  assign \115.read_pipe  = { iffalse, iftrue, cond, 1'hz };
endmodule

module mux_uint1_t_uint25_t_uint25_t_0clk_de264c78(cond, iftrue, iffalse, return_output);
  wire [75:0] \93.read_pipe ;
  input cond;
  wire cond;
  input [24:0] iffalse;
  wire [24:0] iffalse;
  input [24:0] iftrue;
  wire [24:0] iftrue;
  output [24:0] return_output;
  wire [24:0] return_output;
  assign return_output = cond ? iftrue : iffalse;
  assign \93.read_pipe  = { iffalse, iftrue, cond, 25'hzzzzzzz };
endmodule

module top(clk_33p33, blink_return_output);
  output blink_return_output;
  wire blink_return_output;
  input clk_33p33;
  wire clk_33p33;
  blink_0clk_a5a1cd4e blink_0clk_a5a1cd4e (
    .clk(clk_33p33),
    .clock_enable(1'h1),
    .return_output(blink_return_output)
  );
endmodule

module unary_op_not_uint1_t_0clk_de264c78(expr, return_output);
  wire [2:0] \137.read_pipe ;
  input expr;
  wire expr;
  output return_output;
  wire return_output;
  assign return_output = ~ expr;
  assign \137.read_pipe  = { expr, 2'hz };
endmodule
